# Tango imports
from tango import DevState, AttributeProxy, Attr, DevDouble, AttrWriteType, AttrQuality
from tango.server import Device, command
import tango.server

# Local imports
from attribute_calculator.ExpressionParser import parse_expression
#from ExpressionParser import parse_expression

class AttributeCalculator(Device):
  """
  A PyTango device that allows the evaluation of mathematical expressions with external device properties as variables.
  The mathematical expression is added as an attribute to this device. When this attribute is read, 
  the external device properties in the expression are read and the expression is evaluated.
  The result is than stored in the attribute.

  For example, the current of several power supplies can be averaged and stored in an attribute 'ps_avg':
  ps_avg: ( ps1 + ps2 + ps3 ) / 3
  
  The new attribute ps_avg can now be read or polled, for example to plot ps_avg over time with Taurus.
  """
    
  def evaluator(self, expression : list) -> float:
    """Evaluate an expression that is generated by the parse_expression function"""

    # This is a bit of a hacky solution, but it works well.
    # If the expression is just an attribute or number, it is not passed in as a list, but as a str, int or float. 
    # We convert it to a list with one element, so that the evaluator function works on it.
    if not isinstance(expression, list) and isinstance(expression, (int,float,str)):
      return self.evaluator([expression])

    # The initial value of result is equal to the first variable/number in the expression
    if isinstance(expression[0], list): # It is another epxression. (This means it is between brackets so should be evaluated first)
      result = self.evaluator(expression[0])
    elif isinstance(expression[0], (int, float)):
      result = expression[0]
    elif isinstance(expression[0], str) and expression[0] not in ['^', '*', '/', '+', '-']:
      result = self.read_external_attribute(expression[0])
      if result is None: # something went wrong reading the attribute
        return # the error message will already have been set inside the read_external_attribute method
    else:
      self.error_stream(f"The first term of the expression is invalid: {expression[0]}")
      return

    # Now parse the rest of the expression

    operator = None
    variable = None
    for term in expression[1:]:

      if operator is None: # We expect an operator now
        if term in ['+', '-', '/', '*', '^']:
          operator = term
        else: # not a recognized operator
          self.error_stream(f"invalid expression: {term}")
          return

      elif operator is not None: # We expect a variable/number now

        if isinstance(term, list): # It is another expression. (This means it is between brackets so should be evaluated first)
          variable = self.evaluator(term) # recursion
          if variable is None: # something went wrong in the recursion, so stop
            return # the error message will already have been set inside the recursion

        elif isinstance(term, (int, float)):
          variable = term

        elif isinstance(term, str): # It is an external device attribute
          variable = self.read_external_attribute(term)
          if variable is None: # something went wrong reading the attribute
            return # the error message will already have been set inside the read_external_attribute method

        else: # invalid term
          self.error_stream(f"Invalid expression: {term}")
          return

        # We now have our operator and variable, so we can preform the math
        # We don't care about order of operation. The parse_expression is guaranteed to return the data in order that is should be evaluated.
        # Python doesn't have switch cases :(
        if operator == "+":
          result += variable
        elif operator == "-":
          result -= variable
        elif operator == "*":
          result *= variable
        elif operator == "/":
          try: # don't divide by 0!
            result /= variable
          except Exception as e:
            self.error_stream(str(e))
            return
        elif operator == "^":
          result **= variable
        else:
          msg = f"Unidentified operator: {operator}"
          self.error_stream(msg)
          return
        
        operator = None # we expect an operator next again
          
    return result
 
  def read_external_attribute(self, attribute: str) -> float:
    """Read an external device attribute"""
    # Check if the proxy exists
    if attribute not in self.attribute_proxies: # The proxy is not initiated yet
      try: # initialize proxy
        proxy = AttributeProxy(attribute)
      except Exception as e:
        self.error_stream(f"can't initialize proxy attribute {attribute}" + "\n" + str(e))
        return
      
      self.attribute_proxies[attribute] = proxy
    # Read the attribute
    try:
      data = self.attribute_proxies[attribute].read() 
    except Exception as e:
      self.error_stream(f"Can't read attribute {attribute}" + "\n" + str(e))
      return

    # Validate the read data
    if data.is_empty or data.has_failed or not isinstance(data.value, (int, float)):
      self.error_stream(f"Attribute {attribute} has returned invalid data")
      return
  
    # all good, return the data
    return data.value

  @command(dtype_in=str, doc_in="A new expression to be added. Inside the expression, variables/numbers and operators should be separated by a white space. Example: ps_avg = ( ps1 + ps2 ) / 2",
           dtype_out=str, doc_out="Success/error message")
  def AddNewExpression(self, input_formula):
    equal_sign_count = input_formula.count('=')
    if equal_sign_count != 1:
      msg = f"The expression needs to contain at least one equal sign. {equal_sign_count} found."
      self.error_stream(msg)
      return msg

    equal_index = input_formula.find('=')
    attribute_name = input_formula[:equal_index].strip() # everything before = is the attribute name
    expression = input_formula[equal_index+1:] # everything after is the expression
    expression = expression.lstrip() # remove leading white spaces 

    # Parse the expression
    try:
      parsed_expression = parse_expression(expression)
    except Exception as e:
      msg = "Can't parse expression. Did you remember to separate operands and operators by a white space?" + "\n" + str(e)
      self.error_stream(msg)
      return msg
    
    # Save the expression and add the attribute
    self.parsed_expressions[attribute_name] = parsed_expression
    self.expressions[attribute_name] = expression

    attribute = Attr(attribute_name, DevDouble, AttrWriteType.READ) # Specify the attribute as a float and read-only 
    self.add_attribute(attribute, r_meth=self.read) # Add the attribute to the device with the read function evaluates the expression
    self.delete_class_attribute(attribute_name) # Remove the newly created attribute from the device class, so that it is only local to this device.

    msg = f"Attribute added: {attribute_name}."
    self.info_stream(msg)
    return msg

  @command(dtype_in=str, doc_in="Delete a previously added expression by using the attribute name",
           dtype_out=str, doc_out="Success/error message")
  def DeleteExpression(self, attribute_name):
    try:
      self.remove_attribute(attribute_name)      
      msg = f"Removed attribute {attribute_name}."
      self.info_stream(msg)
      return msg

    except Exception as e:
      msg = f"Could not remove attribute {attribute_name}."
      self.error_stream(msg + "\n" + str(e))
      return msg

  @command(dtype_in=str, doc_in="Get the formula for a specified attribute", dtype_out=str)
  def GetAttributeFormula(self, attribute_name):
    try:
      return self.expressions[attribute_name]
    except Exception as e:
      msg = f"Could not fetch expression for attribute {attribute_name}."
      self.error_stream(msg + "\n" + str(e))
      return msg

  def init_device(self):
    try:
      Device.init_device(self)
      
      # These variables should be initialized only when the device is first created.
      # This checks if the device already has these variables, and creates it if it doesn't have them yet.
      # This is a very ugly way of doing this and I am sure there exists a better way, but I couldn't find it for now. I tried with __init__, but it doesn't work.
      if not hasattr(self, 'attribute_proxies'):
        self.attribute_proxies = {}
      if not hasattr(self, 'parsed_expressions'):
        self.parsed_expressions = {}
      if not hasattr(self, 'expressions'):
        self.expressions = {}
      
    except Exception as e:
      self.error_stream("Could not init device." + "\n" + str(e))
      self.set_state(DevState.FAULT)
    else:
      self.set_state(DevState.ON)

  def read(self, attribute):
    """Read an attribute"""
    # I tried to do this with a method that generates and returns a callable which handles the reading. However, this seemed not to work.
    # I believe this is because the read method for the attribute needs to exist in a certain scope (such as a method for a class like this), 
    # and can't just be a reference to a callable function somewhere. However, I am not sure.

    name = attribute.get_name()
    try:
      attribute.set_value(self.evaluator(self.parsed_expressions[name])) # Evaluate the expression with the current values for the external attributes.
    except Exception as e:
      self.error_stream(f"Could not update attribute {name}" + "\n" + str(e))

      try:
        attribute.set_quality(AttrQuality.ATTR_INVALID, True) # Set the data quality to invalid so that the user can handle it further. The 'True' parameter means that a change event is send (if events enabled).
      except Exception as e:
        self.error_stream(f"Could not set attribute quality for {name}" + "\n" + str(e))


  def delete_class_attribute(self, attribute_name):
    """Due to a long standing issue in Tango, dynamically created attributes are also added to the device class. This function is called when a new attribute is created and removes it from the class.
    Inspired by: gitlab.com/sardana-org/sardana/~/blob/3.3.4/src/sardana/tango/pool/PoolDevice.py#L229"""

    class_attributes = self.get_device_class().get_class_attr()
    try:
      attribute_to_remove = class_attributes.get_attr(attribute_name)
      class_attributes.remove_attr(attribute_to_remove.get_name(), attribute_to_remove.get_cl_name())
    except Exception as e:
      self.error_stream(f"Could not remove attribute {attribute_name} from device class" + "\n" + str(e))


def run():
  AttributeCalculator.run_server()

if __name__=="__main__":
  run()
